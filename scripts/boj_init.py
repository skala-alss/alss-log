#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
BOJ ë¬¸ì œ í´ë” ìë™ ì„¸íŒ… ë´‡ (requests + BeautifulSoup + solved.ac)
- í´ë”ëª… 'boj_<id>_...' ë˜ëŠ” --id <id>
- BOJ: ì œëª©/ì‹œê°„/ë©”ëª¨ë¦¬/ìƒ˜í”Œ(ì…Â·ì¶œë ¥) íŒŒì‹± (ê°œí–‰/CR ì •ê·œí™”)
- solved.ac: í‹°ì–´/íƒœê·¸/í‘¼ ì‚¬ëŒ ìˆ˜/í‰ê·  ì‹œë„ â†’ ì†ŒìŠ¤ ìƒë‹¨ ì£¼ì„ìœ¼ë¡œ ì£¼ì…
- tests/sample*.in|.out ìƒì„±, input.txt í¸ì˜ ë³µì‚¬
- run.sh ìƒì„±(ì–¸ì–´ ê³µí†µ): ì†ŒìŠ¤ 1ê°œ ì„ íƒ â†’ testsì˜ ëª¨ë“  .in ì‹¤í–‰ & .out ê²€ì¦
- íŒŒì¼/í´ë” ê·œì¹™
  * ì¼ë°˜: íŒŒì¼ëª… = username_pid.(cpp|py|java)
  * ì§€ì •ê²½ë¡œ ëª¨ë“œ(--dest / --dest-base / BOJ_DEST_BASE):
      - í´ë”ëª… = <id>.<ì œëª©_ì •ì œ>
      - íŒŒì¼ëª… = <id>.<ì œëª©_ì •ì œ>.(cpp|py|java)

ì˜ì¡´: requests, bs4, lxml
"""

import argparse
import os
import re
import sys
import textwrap
import time, shutil, subprocess
import html as ihtml
from pathlib import Path
from typing import List, Tuple, Optional, Dict, Any

import requests
from bs4 import BeautifulSoup

BOJ_BASE = "https://www.acmicpc.net/problem/"
SOLVED_SHOW = "https://solved.ac/api/v3/problem/show?problemId={pid}"

HEADERS = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
    "Accept": "text/html,application/xhtml+xml,application/json",
    "Accept-Language": "ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7",
    "Referer": "https://www.acmicpc.net/",
    "Connection": "close",
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Console Encoding Setup (Force UTF-8 Output)
#   - Git Bash, Windows Console ë“± í™˜ê²½ë³„ ì¸ì½”ë”© ì°¨ì´ë¡œ ì¸í•œ ëª¨ì§€ë°”ì¼€ ë°©ì§€
#   - stdout/stderrë¥¼ UTF-8ë¡œ ì¬ì„¤ì • (Python 3.7+)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _supports_utf8() -> bool:
    enc = (sys.stdout.encoding or '') + (sys.stderr.encoding or '')
    return 'UTF' in enc.upper()

try:
    # Python 3.7+ : í‘œì¤€ ì¶œë ¥ ì¸ì½”ë”©ì„ ê°•ì œë¡œ UTF-8ë¡œ
    sys.stdout.reconfigure(encoding='utf-8', errors='replace')
    sys.stderr.reconfigure(encoding='utf-8', errors='replace')
except Exception:
    # ëª» ë°”ê¾¸ëŠ” í™˜ê²½ ëŒ€ë¹„
    os.environ.setdefault('PYTHONIOENCODING', 'utf-8')

OK = "âœ…" if _supports_utf8() else "[OK]"
WARN = "âš ï¸" if _supports_utf8() else "[WARN]"
SKIP = "â­" if _supports_utf8() else "[SKIP]"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Args & Lang normalize
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(
        description="BOJ ë¬¸ì œ í´ë” ìë™ ì„¸íŒ… ë´‡",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent("""
        ì˜ˆ)
          python boj_init.py cpp --id 17608
          # ê¸°ë³¸ ê²½ë¡œ í™˜ê²½ë³€ìˆ˜ ì‚¬ìš©(BOJ_DEST_BASE) + í´ë” ìƒì„±/ì§„í–‰
          python boj_init.py cpp --id 17608 --dest
          # ê¸°ë³¸ ê²½ë¡œ ë’¤ì— suffixë¥¼ ë¶™ì„
          python boj_init.py cpp --id 17608 --dest +week02/ìŠ¤íƒ
          # ê¸°ë³¸ ê²½ë¡œë¥¼ ì˜µì…˜ìœ¼ë¡œ ì§ì ‘ ì§€ì •
          python boj_init.py cpp --id 17608 --dest-base "C:/TIS/Baekjoon" --dest +week02/ìŠ¤íƒ
          # ìƒì„± í›„ ì¦‰ì‹œ ì±„ì (í•´ë‹¹ ì†ŒìŠ¤ë§Œ ì§€ì •í•´ ìë™ ì‹¤í–‰)
          python boj_init.py java --id 1006 --dest +week02 && ./run.sh "1006.ë¬¸ì œì œëª©.java"
        """),
    )
    p.add_argument("lang", choices=["cpp","py","java","c++","cpp14","python"], help="ì–¸ì–´")
    p.add_argument("--id", type=int, help="ë¬¸ì œ ë²ˆí˜¸(ë¯¸ì§€ì •ì‹œ í´ë”ëª…ì—ì„œ ì¶”ì¶œ)")
    p.add_argument("--username", default="keehoon", help="ì¼ë°˜ ëª¨ë“œ íŒŒì¼ëª…(username_pid)ì˜ username ë¶€ë¶„")
    p.add_argument("--run", action="store_true", help="ìƒì„± í›„ ì¦‰ì‹œ run.shë¡œ ì±„ì  ì‹¤í–‰(í•´ë‹¹ ì†ŒìŠ¤ ìë™ ì„ íƒ)")
    p.add_argument("--no-solvedac", action="store_true", help="solved.ac ì¡°íšŒ ë¹„í™œì„±í™”")
    p.add_argument("--max-tags", type=int, default=8, help="ì£¼ì„ì— í‘œì‹œí•  ìµœëŒ€ íƒœê·¸ ìˆ˜ (ê¸°ë³¸ 8)")
    p.add_argument("--debug", action="store_true", help="ìš”ì²­/ë¦¬íŠ¸ë¼ì´ ìƒì„¸ ë¡œê·¸ ì¶œë ¥")
    p.add_argument("--insecure", action="store_true", help="ì¸ì¦ì„œ ê²€ì¦ ë¹„í™œì„±í™”(ì„ì‹œìš©)")
    p.add_argument("--force", "-f", action="store_true", help="ê¸°ì¡´ íŒŒì¼ì´ ìˆì–´ë„ ë®ì–´ì“°ê¸°(ê¸°ë³¸: ê±´ë„ˆëœ€)")

    # ì§€ì •ê²½ë¡œ: --destì€ ê°’ì´ ì—†ì–´ë„ í—ˆìš©(ê¸°ë³¸ê²½ë¡œë§Œ ì‚¬ìš©), '+suffix' ë˜ëŠ” ê²½ë¡œ ë¬¸ìì—´ë„ í—ˆìš©
    p.add_argument("--dest", nargs="?", const="", type=str,
                   help="ë¬¸ì œ í´ë”ë¥¼ ì§€ì • ê²½ë¡œì— ìƒì„±í•´ ê·¸ í´ë”ì—ì„œ ì‘ì—…. "
                        "ê°’ì´ ì—†ìœ¼ë©´ --dest-base/BOJ_DEST_BASEë§Œ ì‚¬ìš©, "
                        "'+suffix'ë©´ ê¸°ë³¸ê²½ë¡œ ë’¤ì— ë§ë¶™ì„, ê²½ë¡œ ë¬¸ìì—´ì´ë©´ ê·¸ ê²½ë¡œ ì‚¬ìš©.")
    p.add_argument("--dest-base", type=str,
                   help="ì§€ì •ê²½ë¡œ ê¸°ë³¸ê°’. ë¯¸ì§€ì • ì‹œ í™˜ê²½ë³€ìˆ˜ BOJ_DEST_BASE ì‚¬ìš©")

    em = p.add_mutually_exclusive_group()
    em.add_argument("--tier-emoji", dest="tier_emoji", action="store_true", help="í‹°ì–´ ì´ëª¨ì§€ ì‚¬ìš©")
    em.add_argument("--no-tier-emoji", dest="tier_emoji", action="store_false", help="í‹°ì–´ ì´ëª¨ì§€ ë¹„í™œì„±í™”")
    p.set_defaults(tier_emoji=True)
    return p.parse_args()

def normalize_lang(lang: str) -> str:
    if lang in ["cpp","c++","cpp14"]: return "cpp"
    if lang in ["py","python"]: return "py"
    return "java"

def infer_id_from_dir() -> Optional[int]:
    name = Path.cwd().name
    m = re.match(r"^[Bb][Oo][Jj]_([0-9]+)_.*$", name)
    if m: return int(m.group(1))
    m = re.match(r"^([0-9]+)[._-].*$", name)  # 17608.ì œëª© / 17608_ì œëª© / 17608-ì œëª©
    if m: return int(m.group(1))
    return None

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Sample text clean
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def clean_sample_text(s: str) -> str:
    if s is None:
        return ""
    s = ihtml.unescape(s)
    s = s.replace("\r\n", "\n").replace("\r", "\n")
    s = re.sub(r"\n{3,}", "\n\n", s)
    s = re.sub(r"\n+\n", "\n\n", s)  # ê³¼ë„í•œ ë¹ˆì¤„ ì••ì¶•
    s = re.sub(r"[ \t]+$", "", s, flags=re.M).strip("\n") + "\n"
    return s

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Naming helpers
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def sanitize_java_identifier(name: str) -> str:
    s = re.sub(r"[^A-Za-z0-9_]", "_", name)
    if not s: s = "_"
    if s[0].isdigit(): s = "_" + s
    return s

def unified_basename(username: str, pid: int) -> str:
    return sanitize_java_identifier(f"{username}_{pid}")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Dest path helpers
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_FORBID_MAP = {"/":"ï¼","\\":"ï¼¼","?":"ï¼Ÿ",":":"ï¼š","*":"ï¼Š","\"":"ï¼‚","<":"ï¼œ",">":"ï¼","|":"ï½œ"}
_RESERVED_WIN = re.compile(r"^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])$", re.IGNORECASE)

def sanitize_title_for_dir(title: str) -> str:
    s = "".join(ch for ch in title if ord(ch) >= 32)
    for k,v in _FORBID_MAP.items(): s = s.replace(k, v)
    s = re.sub(r"\s+", "_", s.strip())
    s = re.sub(r"_+", "_", s)
    s = re.sub(r"[ .]+$", "", s)
    s = re.sub(r"^\.+", "", s)
    if not s: s = "_"
    if _RESERVED_WIN.match(s): s = "_" + s
    return s

def resolve_dest_path(args) -> Optional[Path]:
    base = args.dest_base or os.environ.get("BOJ_DEST_BASE")
    if args.dest is None:
        return None
    if args.dest == "":
        if not base:
            raise ValueError("--dest ì‚¬ìš© ì‹œ --dest-base ë˜ëŠ” BOJ_DEST_BASEê°€ í•„ìš”í•©ë‹ˆë‹¤.")
        return Path(base).expanduser()
    if args.dest.startswith("+"):
        if not base:
            raise ValueError("--dest +suffix ì‚¬ìš© ì‹œ --dest-base ë˜ëŠ” BOJ_DEST_BASEê°€ í•„ìš”í•©ë‹ˆë‹¤.")
        return (Path(base).expanduser() / args.dest[1:]).resolve()
    return Path(args.dest).expanduser().resolve()

def make_problem_folder(parent: Path, name: str) -> Path:
    target = parent / name
    target.mkdir(parents=True, exist_ok=True)
    return target

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# HTTP helpers
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def http_get_text(url: str, *, verify: bool=True, debug: bool=False) -> str:
    sess = requests.Session()
    sess.headers.update(HEADERS)
    for i in range(3):
        try:
            r = sess.get(url, timeout=10, verify=verify, allow_redirects=True)
            if debug: print(f"[GET {i+1}/3] {r.status_code} {r.reason}", file=sys.stderr)
            if r.status_code == 200: return r.text
            time.sleep(1 + i)
        except requests.RequestException as e:
            if debug: print(f"[GET {i+1}/3] EXC: {e}", file=sys.stderr)
            time.sleep(1 + i)
    if shutil.which("curl"):
        try:
            if debug: print("[curl fallback] running curl -fsSL ...", file=sys.stderr)
            out = subprocess.check_output(["curl","-fsSL","-A",HEADERS["User-Agent"], url], text=True)
            return out
        except Exception as e:
            if debug: print(f"[curl fallback] EXC: {e}", file=sys.stderr)
    raise RuntimeError(f"í˜ì´ì§€ ìš”ì²­ ì‹¤íŒ¨: {url}")

def http_get_json(url: str) -> Optional[Dict[str, Any]]:
    for _ in range(3):
        try:
            r = requests.get(url, headers=HEADERS, timeout=10)
            if r.status_code == 200: return r.json()
        except requests.RequestException:
            pass
    return None

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# BOJ parsing
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def extract_text(el) -> str:
    return el.get_text("\n").strip()

def parse_problem(html: str) -> dict:
    soup = BeautifulSoup(html, "lxml")

    title = ""
    title_span = soup.select_one("#problem_title")
    if title_span: title = extract_text(title_span)
    if not title:
        t = soup.select_one("head > title")
        if t:
            raw = extract_text(t)
            title = re.sub(r"^\s*\d+\s*[:\-]\s*", "", raw)
            title = re.sub(r"\s*-\s*.*$", "", title).strip()

    time_limit = None
    memory_limit = None
    info_table = soup.select_one(".problem-info, .table-responsive table")
    if info_table:
        text_blob = extract_text(info_table)
        m = re.search(r"ì‹œê°„\s*ì œí•œ\s*([^\n]+)", text_blob) or re.search(r"Time\s*Limit\s*:?[\s]*([^\n]+)", text_blob, re.I)
        if m: time_limit = m.group(1).strip()
        m = re.search(r"ë©”ëª¨ë¦¬\s*ì œí•œ\s*([^\n]+)", text_blob) or re.search(r"Memory\s*Limit\s*:?[\s]*([^\n]+)", text_blob, re.I)
        if m: memory_limit = m.group(1).strip()

    samples: List[Tuple[str, str]] = []
    input_pres = soup.select('pre[id^="sample-input"]')
    output_pres = soup.select('pre[id^="sample-output"]')

    def sort_key(pre):
        m = re.search(r"(\d+)$", pre.get("id",""))
        return int(m.group(1)) if m else 0

    input_pres.sort(key=sort_key); output_pres.sort(key=sort_key)

    if input_pres and output_pres and len(input_pres) == len(output_pres):
        for ip, op in zip(input_pres, output_pres):
            iin  = clean_sample_text(extract_text(ip))
            oout = clean_sample_text(extract_text(op))
            samples.append((iin, oout))
    else:
        def collect_by_heading(patterns: List[str]) -> List[str]:
            texts = []
            for h in soup.select("h3, h4, h5"):
                label = extract_text(h)
                if any(pat.lower() in label.lower() for pat in patterns):
                    nxt_pre = h.find_next("pre")
                    if nxt_pre: texts.append(extract_text(nxt_pre))
            return texts
        ins = collect_by_heading(["ì˜ˆì œ ì…ë ¥", "Sample Input"])
        outs = collect_by_heading(["ì˜ˆì œ ì¶œë ¥", "Sample Output"])
        for i in range(max(len(ins), len(outs))):
            samples.append((clean_sample_text(ins[i] if i < len(ins) else ""),
                            clean_sample_text(outs[i] if i < len(outs) else "")))

    return {"title": title, "time_limit": time_limit, "memory_limit": memory_limit, "samples": samples}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# solved.ac helpers
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TIER_NAMES = [None,
    "Bronze V","Bronze IV","Bronze III","Bronze II","Bronze I",
    "Silver V","Silver IV","Silver III","Silver II","Silver I",
    "Gold V","Gold IV","Gold III","Gold II","Gold I",
    "Platinum V","Platinum IV","Platinum III","Platinum II","Platinum I",
    "Diamond V","Diamond IV","Diamond III","Diamond II","Diamond I",
    "Ruby V","Ruby IV","Ruby III","Ruby II","Ruby I"
]

def level_to_name(level: Optional[int]) -> Optional[str]:
    if isinstance(level, int) and 1 <= level < len(TIER_NAMES): return TIER_NAMES[level]
    return None

def tier_icon(tier_name: Optional[str]) -> str:
    if not tier_name: return ""
    return {"Bronze":"ğŸŸ«","Silver":"âšª","Gold":"ğŸŸ¡","Platinum":"ğŸŸ©","Diamond":"ğŸ’","Ruby":"â¤ï¸"}.get(tier_name.split()[0], "")

def fetch_solved_meta(pid: int, max_tags: int, tier_emoji: bool) -> Optional[Dict[str, Any]]:
    data = http_get_json(SOLVED_SHOW.format(pid=pid))
    if not data or "problemId" not in data: return None
    tier = level_to_name(data.get("level"))
    if tier_emoji and tier:
        icon = tier_icon(tier)
        if icon: tier = f"{icon} {tier}"
    tags: List[str] = []
    for t in data.get("tags", []):
        ko = next((d.get("name") for d in t.get("displayNames", []) if d.get("language")=="ko"), None)
        tags.append((ko or t.get("key") or "").strip())
    tags = [x for x in sorted(tags) if x][:max_tags]
    return {
        "tier": tier,
        "solved_count": data.get("solvedUserCount") or data.get("acceptedUserCount"),
        "average_tries": data.get("averageTries"),
        "is_solvable": data.get("isSolvable"),
        "tags": tags,
    }

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# File utils & templates
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def ensure_dir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)

def safe_write(path: Path, content: str, *, force: bool, label: str) -> str:
    """
    íŒŒì¼ ì“°ê¸°(UTF-8). ë°˜í™˜: 'created' | 'overwritten' | 'skipped'
    """
    if path.exists():
        if force:
            path.write_text(content, encoding="utf-8")
            print(f"â†» ë®ì–´ì”€: {label} â†’ {path}")
            return "overwritten"
        else:
            print(f"â­  ê±´ë„ˆëœ€(ì¡´ì¬í•¨): {label} â†’ {path}")
            return "skipped"
    else:
        path.write_text(content, encoding="utf-8")
        print(f"ï¼‹ ìƒì„±: {label} â†’ {path}")
        return "created"

def build_meta_lines(pid: int, boj: dict, solved: Optional[dict]) -> List[str]:
    lines = [f"{pid} â€“ {boj.get('title','')}",
             f"https://www.acmicpc.net/problem/{pid}",
             f"solved.ac: https://solved.ac/search?query={pid}"]
    if boj.get("time_limit"):   lines.append(f"ì‹œê°„ ì œí•œ: {boj['time_limit']}")
    if boj.get("memory_limit"): lines.append(f"ë©”ëª¨ë¦¬ ì œí•œ: {boj['memory_limit']}")
    if solved:
        if solved.get("tier"): lines.append(f"í‹°ì–´: {solved['tier']}")
        if solved.get("tags"): lines.append("íƒœê·¸: " + ", ".join(solved["tags"]))
        if solved.get("solved_count") is not None: lines.append(f"í‘¼ ì‚¬ëŒ ìˆ˜: {solved['solved_count']:,}")
        if solved.get("average_tries") is not None: lines.append(f"í‰ê·  ì‹œë„: {solved['average_tries']:.2f}")
    return lines

def comment_block(lang: str, lines: List[str]) -> str:
    prefix = "# " if lang=="py" else "// "
    return "\n".join(prefix + l for l in lines) + "\n\n"

def body_cpp() -> str:
    return """#include <iostream>
#if defined(_WIN32)
  #include <io.h>
  #include <cstdio>
#else
  #include <unistd.h>
  #include <cstdio>
#endif

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // í‘œì¤€ì…ë ¥ì´ í„°ë¯¸ë„ì´ë©´ input.txtë¡œ ëŒ€ì²´ (íŒŒì´í”„ ì…ë ¥ ì‹œì—ëŠ” ê·¸ëŒ€ë¡œ cin)
#if defined(_WIN32)
    if (_isatty(_fileno(stdin))) { freopen("input.txt", "r", stdin); }
#else
    if (isatty(fileno(stdin))) { freopen("input.txt", "r", stdin); }
#endif

    int N, M;
    if (!(cin >> N >> M)) return 0;
    cout << "N: " << N << " M: " << M << "\\n";
    return 0;
}
"""

def body_py() -> str:
    return """import sys, io

def input_stream():
    try:
        if not sys.stdin.isatty():
            return io.TextIOWrapper(sys.stdin.buffer, encoding="utf-8", newline="")
    except Exception:
        pass
    try:
        return open("input.txt", "r", encoding="utf-8", newline="")
    except FileNotFoundError:
        return io.TextIOWrapper(sys.stdin.buffer, encoding="utf-8", newline="")

def main() -> None:
    f = input_stream()
    line = f.readline().strip()
    if not line:
        return
    N, M = map(int, line.split())
    print(f"N: {N} M: {M}")

if __name__ == "__main__":
    main()
"""

def body_java() -> str:
    return """import java.io.*;
import java.util.*;
import java.nio.charset.StandardCharsets;

// public class Main {
class Main {
    public static void main(String[] args) throws Exception {
        InputStream in = System.in;
        try {
            // íŒŒì´í”„ëœ ì…ë ¥ì´ ì—†ê³  input.txtê°€ ìˆìœ¼ë©´ ê·¸ê²ƒìœ¼ë¡œ ì „í™˜
            if (in.available() == 0) {
                File f = new File("input.txt");
                if (f.exists()) in = new FileInputStream(f);
            }
        } catch (Exception ignored) {}

        BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        System.out.println("N: " + N + " M: " + M);
    }
}
"""

def generate_source(lang: str, boj: dict, solved: Optional[dict]) -> str:
    header = comment_block(lang, build_meta_lines(int(boj.get('id', 0)) or 0, boj, solved))
    return header + (body_cpp() if lang=="cpp" else body_py() if lang=="py" else body_java())

def make_vscode_ccpp() -> str:
    return """{
  "configurations": [
    {
      "name": "Win64",
      "includePath": [
                "${workspaceFolder}/**"
            ],
            "defines": [
                "_DEBUG",
                "UNICODE",
                "_UNICODE"
            ],
            "windowsSdkVersion": "10.0.22621.0",
            "compilerPath": "C:/msys64/ucrt64/bin/g++.exe",
            "cStandard": "c99",
            "cppStandard": "c++14",
            "intelliSenseMode": "windows-gcc-x64",
            "configurationProvider": "ms-vscode.cpptools"
        }
    ],
    "version": 4
}
"""

def make_run_sh() -> str:
    return r"""#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "${BASH_SOURCE[0]}")"
shopt -s nullglob

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 0) ê³µí†µ ìœ í‹¸
#   - unixify: CRLFâ†’LF ì •ê·œí™” + ë§ˆì§€ë§‰ ì¤„ ê°œí–‰(LF) ë³´ì¥
#     (gawkì˜ RS/RTë¥¼ ì´ìš©í•´ EOF ê°œí–‰ ìœ ë¬´ë¥¼ ì •í™•íˆ ì²˜ë¦¬)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
unixify() {
  gawk 'BEGIN{RS="\r?\n"; ORS=""}
       { printf "%s", $0; if (RT!="") printf "\n" }
       END { if (NR>0 && RT=="") printf "\n" }'
}
have() { command -v "$1" >/dev/null 2>&1; }

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 1) ì†ŒìŠ¤ ì„ íƒ
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pick="${1:-}"
cands=( *.cpp *.py *.java )
if [[ -z "${pick}" ]]; then
  if [[ ${#cands[@]} -eq 0 ]]; then
    echo "ì†ŒìŠ¤ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤."; exit 1
  fi
  echo "ğŸ” ì‹¤í–‰í•  ì†ŒìŠ¤ ì„ íƒ:"
  select pick in "${cands[@]}"; do
    [[ -n "${pick:-}" ]] && break
  done
fi
[[ -f "$pick" ]] || { echo "ìœ íš¨í•œ ì†ŒìŠ¤ íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤: $pick"; exit 1; }

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 2) C++ì´ë©´ UCRT64ë¡œ ì¬ì‹¤í–‰(bounce)
#    (ì´ë¯¸ UCRT64ë©´ ê·¸ëŒ€ë¡œ ì§„í–‰)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ext="${pick##*.}"
MSYS_NOW="${MSYSTEM:-}"
if [[ "$ext" == "cpp" && "$MSYS_NOW" != "UCRT64" ]]; then
  PICK_FILE="$(mktemp -t run_pick.XXXXXX)"
  printf '%s' "$pick" > "$PICK_FILE"
  trap 'rm -f "$PICK_FILE"' EXIT

  UCRT_BASH="/c/msys64/usr/bin/bash.exe"
  UCRT_ENV="/c/msys64/usr/bin/env.exe"

  if [[ -x "$UCRT_BASH" && -x "$UCRT_ENV" ]]; then
    echo "â†ª UCRT64ë¡œ ì¬ì‹¤í–‰(bash.exe -lc)"
    exec "$UCRT_ENV" MSYSTEM=UCRT64 CHERE_INVOKING=1 \
         "$UCRT_BASH" -lc "cd \"$PWD\"; p=\$(cat \"$PICK_FILE\"); rm -f \"$PICK_FILE\"; bash ./run.sh \"\$p\""
  else
    echo "â— UCRT bashë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: $UCRT_BASH (ë˜ëŠ” env.exe)"
    exit 1
  fi
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 3) ì…ë ¥ íŒŒì¼ ëª©ë¡
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
inputs=( tests/*.in )
if [[ ${#inputs[@]} -eq 0 ]]; then
  inputs=( input.txt )
fi

mkdir -p out

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 4) ì–¸ì–´ë³„ ë¹Œë“œ/ì‹¤í–‰ ì»¤ë§¨ë“œ ì¤€ë¹„
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
run_cmd() { :; }  # placeholder
case "$ext" in
  cpp)
    gpp="C:/msys64/ucrt64/bin/g++.exe"
    [[ -x "$gpp" ]] || gpp="g++"
    exe="./main.exe"
    echo "âš™ï¸  compile: $pick -> $exe"
    "$gpp" "$pick" -std=c++14 -O2 -pipe -static -s -o "$exe"
    run_cmd() { ./main.exe; }
    ;;
  py)
    run_cmd() { python -X utf8 "$pick"; }
    ;;
  java)
    # ì„ì‹œ ë¹Œë“œ ë””ë ‰í„°ë¦¬(ì§€ì • ì—†ìœ¼ë©´ ìë™ ì‚­ì œ)
    JAVA_BUILD_DIR="${JAVA_BUILD_DIR:-}"
    if [[ -z "$JAVA_BUILD_DIR" ]]; then
      build_dir="$(mktemp -d)"
      CLEAN_BUILD=1
    else
      build_dir="$JAVA_BUILD_DIR"
      mkdir -p "$build_dir"
      CLEAN_BUILD=0
    fi
    trap '[[ "${CLEAN_BUILD:-0}" == "1" ]] && rm -rf "$build_dir"' EXIT

    echo "âš™ï¸  javac -encoding UTF-8 -d \"$build_dir\" $pick"
    javac -encoding UTF-8 -d "$build_dir" "$pick"

    run_cmd() { java -Dfile.encoding=UTF-8 -cp "$build_dir" Main; }
    ;;
  *)
    echo "ì•Œ ìˆ˜ ì—†ëŠ” í™•ì¥ì: $pick"; exit 1 ;;
esac

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 5) ì‹¤í–‰ & ê²€ì¦ (CR/LF ì •ê·œí™”, diff ì—†ìœ¼ë©´ cmp fallback)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
for in_file in "${inputs[@]}"; do
  tmp_out="$(mktemp)"
  out_file="out/$(basename "$pick").$(basename "$in_file").out"
  echo "â–¶ $pick < $(basename "$in_file")"
  run_cmd < "$in_file" > "$tmp_out" || true

  exp=""
  if [[ "$in_file" == tests/*.in ]]; then
    exp="${in_file%.in}.out"
  fi

  if [[ -n "$exp" && -f "$exp" ]]; then
    if have diff; then
      if diff -u <(unixify < "$exp") <(unixify < "$tmp_out") > /dev/null; then
        echo "âœ… PASS"
      else
        echo "âŒ FAIL"
        diff -u <(unixify < "$exp") <(unixify < "$tmp_out") || true
      fi
    else
      exp_u="$(mktemp)"; tmp_u="$(mktemp)"
      unixify < "$exp" > "$exp_u"
      unixify < "$tmp_out" > "$tmp_u"
      if cmp -s "$exp_u" "$tmp_u"; then
        echo "âœ… PASS (cmp)"
      else
        echo "âŒ FAIL (cmp) â€” ì‹œìŠ¤í…œì— diffê°€ ì—†ì–´ ìƒì„¸ ë¹„êµëŠ” ìƒëµ"
        echo "---- expected (head) ----"; head -n 40 "$exp_u" || true
        echo "---- actual   (head) ----"; head -n 40 "$tmp_u" || true
        echo "-------------------------"
      fi
      rm -f "$exp_u" "$tmp_u"
    fi
  else
    echo "â„¹ï¸  ë¹„êµìš© ì •ë‹µ íŒŒì¼ ì—†ìŒ"
  fi

  mv -f "$tmp_out" "$out_file"
done
"""

def open_vscode() -> bool:
    for exe in ("code.cmd", "code"):
        if shutil.which(exe):
            try:
                subprocess.Popen([exe, "."], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                return True
            except Exception:
                pass
    return False

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Main
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def main() -> None:
    args = parse_args()
    lang = normalize_lang(args.lang)
    pid = args.id or infer_id_from_dir()
    if not pid:
        print("â— í´ë”ëª…ì—ì„œ ë¬¸ì œ ë²ˆí˜¸ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. --id <ë²ˆí˜¸> ë¥¼ ì§€ì •í•˜ì„¸ìš”.", file=sys.stderr)
        sys.exit(1)

    # BOJ
    url = BOJ_BASE + str(pid)
    html = http_get_text(url, verify=not args.insecure, debug=args.debug)
    boj_meta = parse_problem(html)
    boj_meta["id"] = pid
    if not boj_meta["title"]:
        print("â— ì œëª© íŒŒì‹± ì‹¤íŒ¨", file=sys.stderr); sys.exit(2)
    print(f"â–¶ ì œëª©: {boj_meta['title']}")
    if boj_meta.get("time_limit") or boj_meta.get("memory_limit"):
        print(f"   (ì‹œê°„: {boj_meta.get('time_limit')}, ë©”ëª¨ë¦¬: {boj_meta.get('memory_limit')})")

    # solved.ac (ì‹¤íŒ¨í•´ë„ ê³„ì†)
    solved_meta: Optional[dict] = None
    if not args.no_solvedac:
        try:
            solved_meta = fetch_solved_meta(pid, max_tags=args.max_tags, tier_emoji=args.tier_emoji)
            if solved_meta and solved_meta.get("tier"):
                preview_tags = ", ".join(solved_meta.get("tags", [])[:5])
                print(f"   (í‹°ì–´: {solved_meta['tier']}" + (f", íƒœê·¸: {preview_tags}" if preview_tags else "") + ")")
        except Exception:
            solved_meta = None

    # ì§€ì •ê²½ë¡œ í•´ì„
    try:
        dest_parent = resolve_dest_path(args)
    except ValueError as e:
        print(f"â— {e}", file=sys.stderr); sys.exit(4)

    # ê²½ë¡œ/íŒŒì¼ëª… ê²°ì •
    if dest_parent:
        dir_title = sanitize_title_for_dir(boj_meta["title"])
        folder_name = f"{pid}.{dir_title}"
        target_dir = make_problem_folder(dest_parent, folder_name)
        os.chdir(target_dir)
        print(f"ğŸ“‚ ì‘ì—… í´ë”: {target_dir}")
        file_base = folder_name
        if lang == "cpp":   src_path = Path(f"{file_base}.cpp")
        elif lang == "py":  src_path = Path(f"{file_base}.py")
        else:               src_path = Path(f"{file_base}.java")
    else:
        base = unified_basename(args.username, pid)
        if lang == "cpp":   src_path = Path(f"{base}.cpp")
        elif lang == "py":  src_path = Path(f"{base}.py")
        else:               src_path = Path(f"{base}.java")

    # tests/ ë° input.txt (ê°œë³„ íŒŒì¼ ë‹¨ìœ„ë¡œ skip/force)
    tests_dir = Path("tests"); ensure_dir(tests_dir)
    samples = boj_meta["samples"]

    if not samples:
        safe_write(Path("input.txt"), "", force=args.force, label="input.txt")
        print("âš ï¸ ìƒ˜í”Œ ë¯¸ë°œê²¬ â†’ ë¹ˆ input.txt ìœ ì§€/ìƒì„±")
    else:
        # input.txt = ì²« ìƒ˜í”Œ ì…ë ¥
        safe_write(Path("input.txt"), samples[0][0], force=args.force, label="input.txt")
        # sample*.in/out
        for i, (iin, oout) in enumerate(samples, 1):
            safe_write(tests_dir / f"sample{i}.in", iin, force=args.force, label=f"tests/sample{i}.in")
            if oout.strip():
                safe_write(tests_dir / f"sample{i}.out", oout, force=args.force, label=f"tests/sample{i}.out")

    # ì†ŒìŠ¤ ìƒì„± (ë©”íƒ€ ì£¼ì„ í—¤ë” í¬í•¨)
    source_text = generate_source(lang, boj_meta, solved_meta)
    _src_status = safe_write(src_path, source_text, force=args.force, label=src_path.name)

    # VSCode C++ ì„¤ì •
    if lang == "cpp":
        vscode_dir = Path(".vscode"); ensure_dir(vscode_dir)
        cprop = vscode_dir / "c_cpp_properties.json"
        safe_write(cprop, make_vscode_ccpp(), force=args.force, label=str(cprop))

    # run.sh ìƒì„±(ì–¸ì–´ ê³µí†µ)
    run_sh = Path("run.sh")
    safe_write(run_sh, make_run_sh(), force=args.force, label="run.sh")
    try:
        os.chmod(run_sh, 0o755)
    except Exception:
        pass

    print(f"âœ… ì™„ë£Œ (ìƒì„±/ê°±ì‹ ) â†’ {src_path}  tests/  input.txt  run.sh")

    # VS Code ì—´ê¸°
    if open_vscode(): print("ğŸŸ¦ VS Code ì—´ê¸°: ì™„ë£Œ")
    else:             print("â„¹ï¸ VS Code ì‹¤í–‰ íŒŒì¼(code) ë¯¸ê²€ì¶œ â€” ìˆ˜ë™ìœ¼ë¡œ ì—´ì–´ ì£¼ì„¸ìš”.")

    # ì¦‰ì‹œ ì‹¤í–‰ (--run) â†’ ë°©ê¸ˆ ë§Œë“ (ë˜ëŠ” ê¸°ì¡´) ì†ŒìŠ¤ ì§€ì •í•˜ì—¬ run.sh í˜¸ì¶œ
    if args.run:
        pick_name = src_path.name
        cmd = f'./run.sh "{pick_name}"' if os.name != "nt" else f'bash ./run.sh "{pick_name}"'
        print(f"â–¶ ì‹¤í–‰: {cmd}")
        os.system(cmd)

if __name__ == "__main__":
    main()
